/******/ (function(modules) {
  // webpackBootstrap
  /******/ // The module cache
  /******/ var installedModules = {}; // The require function
  /******/
  /******/ /******/ function __webpack_require__(moduleId) {
    /******/
    /******/ // Check if module is in cache
    /******/ if (installedModules[moduleId]) {
      /******/ return installedModules[moduleId].exports;
      /******/
    } // Create a new module (and put it into the cache)
    /******/ /******/ var module = (installedModules[moduleId] = {
      /******/ i: moduleId,
      /******/ l: false,
      /******/ exports: {}
      /******/
    }); // Execute the module function
    /******/
    /******/ /******/ modules[moduleId].call(
      module.exports,
      module,
      module.exports,
      __webpack_require__
    ); // Flag the module as loaded
    /******/
    /******/ /******/ module.l = true; // Return the exports of the module
    /******/
    /******/ /******/ return module.exports;
    /******/
  } // expose the modules object (__webpack_modules__)
  /******/
  /******/
  /******/ /******/ __webpack_require__.m = modules; // expose the module cache
  /******/
  /******/ /******/ __webpack_require__.c = installedModules; // define getter function for harmony exports
  /******/
  /******/ /******/ __webpack_require__.d = function(exports, name, getter) {
    /******/ if (!__webpack_require__.o(exports, name)) {
      /******/ Object.defineProperty(exports, name, {
        enumerable: true,
        get: getter
      });
      /******/
    }
    /******/
  }; // define __esModule on exports
  /******/
  /******/ /******/ __webpack_require__.r = function(exports) {
    /******/ if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
      /******/ Object.defineProperty(exports, Symbol.toStringTag, {
        value: "Module"
      });
      /******/
    }
    /******/ Object.defineProperty(exports, "__esModule", { value: true });
    /******/
  }; // create a fake namespace object // mode & 1: value is a module id, require it // mode & 2: merge all properties of value into the ns // mode & 4: return value when already ns object // mode & 8|1: behave like require
  /******/
  /******/ /******/ /******/ /******/ /******/ /******/ __webpack_require__.t = function(
    value,
    mode
  ) {
    /******/ if (mode & 1) value = __webpack_require__(value);
    /******/ if (mode & 8) return value;
    /******/ if (
      mode & 4 &&
      typeof value === "object" &&
      value &&
      value.__esModule
    )
      return value;
    /******/ var ns = Object.create(null);
    /******/ __webpack_require__.r(ns);
    /******/ Object.defineProperty(ns, "default", {
      enumerable: true,
      value: value
    });
    /******/ if (mode & 2 && typeof value != "string")
      for (var key in value)
        __webpack_require__.d(
          ns,
          key,
          function(key) {
            return value[key];
          }.bind(null, key)
        );
    /******/ return ns;
    /******/
  }; // getDefaultExport function for compatibility with non-harmony modules
  /******/
  /******/ /******/ __webpack_require__.n = function(module) {
    /******/ var getter =
      module && module.__esModule
        ? /******/ function getDefault() {
            return module["default"];
          }
        : /******/ function getModuleExports() {
            return module;
          };
    /******/ __webpack_require__.d(getter, "a", getter);
    /******/ return getter;
    /******/
  }; // Object.prototype.hasOwnProperty.call
  /******/
  /******/ /******/ __webpack_require__.o = function(object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
  }; // __webpack_public_path__
  /******/
  /******/ /******/ __webpack_require__.p = ""; // Load entry module and return exports
  /******/
  /******/
  /******/ /******/ return __webpack_require__(
    (__webpack_require__.s = "./js/main.js")
  );
  /******/
})(
  /************************************************************************/
  /******/ {
    /***/ "./js/main.js":
      /*!********************!*\
  !*** ./js/main.js ***!
  \********************/
      /*! no exports provided */
      /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        eval(
          '__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var smoothState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! smoothState */ "./node_modules/smoothState/src/jquery.smoothState.js");\n/* harmony import */ var smoothState__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(smoothState__WEBPACK_IMPORTED_MODULE_0__);\n// sidebar functionality\n\n\njQuery(window).scroll(function() {\n  //scroll position variable\n  var scroll = jQuery(window).scrollTop();\n\n  if (scroll >= 633) {\n    jQuery("#left-sidebar").addClass("fixed-sidebar");\n    jQuery("#right-sidebar").addClass("fixed-sidebar");\n  }\n  if (scroll <= 632) {\n    jQuery("#left-sidebar").removeClass("fixed-sidebar");\n    jQuery("#right-sidebar").removeClass("fixed-sidebar");\n  }\n});\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n///////////////////////// Mobile and desktop navigation classes //////////////////////////////////////////////////\nif (jQuery(window).width() <= 667) {\n  // var Parallax = require(\'parallax-js\')\n  // var scene = document.getElementById(\'wrapper-footer-full\');\n  // var parallaxInstance = new Parallax(scene);\n\n  //use small nav for mobile\n  jQuery(".navbar").addClass("navbar-small");\n\n  jQuery(window).scroll(function() {\n    //scroll position variable\n    var scroll = jQuery(window).scrollTop();\n\n    if (scroll >= 168) {\n      jQuery(".navbar").addClass("opacity0");\n    }\n    if (scroll <= 167) {\n      jQuery(".navbar").removeClass("opacity0");\n    }\n\n    if (scroll >= 218) {\n      jQuery(".navbar").addClass("fixed-top opacity100");\n      jQuery(".header-navbar").addClass("jumpfix"); //accounts for position-fixed CSS change\n    }\n    if (scroll <= 217) {\n      jQuery(".navbar").removeClass("fixed-top opacity100");\n      jQuery(".header-navbar").removeClass("jumpfix"); //remove extra classes and put navs back at top\n    }\n  });\n} else {\n  //end small screens so desktop next\n\n  jQuery(window).scroll(function() {\n    //scroll position variable\n    var scroll = jQuery(window).scrollTop();\n\n    if (scroll >= 168) {\n      jQuery(".navbar").addClass("opacity0");\n    }\n    if (scroll <= 167) {\n      jQuery(".navbar").removeClass("opacity0");\n    }\n\n    if (scroll >= 218) {\n      jQuery(".navbar").addClass("navbar-small fixed-top opacity100"); //shrink nav and fix it to top\n      jQuery(".header-navbar").addClass("jumpfix");\n    }\n    if (scroll <= 217) {\n      jQuery(".navbar").removeClass("navbar-small fixed-top opacity100"); //expand nav and remove fixed\n      jQuery(".header-navbar").removeClass("jumpfix");\n    }\n  });\n} //end regular\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n(function($) {\n  "use strict";\n\n  ///////////////////////// Move the content up by the height of the navbar object for a transparent nav effect ////\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  if (jQuery(window).width() > 667) {\n    var navHeight = $(".header-navbar").height();\n    $("#page-wrapper").css("margin-top", -navHeight);\n  }\n\n  ///////////////////////// for putting wordpress galleries linked to images/videos in lightbox ////////////////////\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  $(".cortex-popup-video").magnificPopup({\n    disableOn: 700,\n    type: "iframe",\n    mainClass: "mfp-zoom-in",\n    removalDelay: 160,\n    preloader: false,\n    fixedContentPos: false\n  });\n\n  $(\n    \'.wp-block-gallery a[href$=".jpg"], .wp-block-gallery a[href$=".jpeg"], .wp-block-gallery a[href$=".png"], .wp-block-gallery a[href$=".gif, "], .cortex-popup\'\n  ).click(function(e) {\n    e.preventDefault();\n\n    var items = [];\n    var firstItem = $(this).attr("href");\n    var firstCaption = $(this).attr("title");\n\n    items.push({\n      src: firstItem,\n      title: firstCaption\n    });\n\n    //items after\n    $(this)\n      .parent()\n      .parent()\n      .nextAll()\n      .children()\n      .find("a")\n      .each(function() {\n        var imageLink = $(this).attr("href");\n        var imageCaption = $(this).attr("title");\n        items.push({\n          src: imageLink,\n          title: imageCaption\n        });\n      });\n\n    //items before\n    $(this)\n      .parent()\n      .parent()\n      .prevAll()\n      .children()\n      .find("a")\n      .each(function() {\n        var imageLink = $(this).attr("href");\n        var imageCaption = $(this).attr("title");\n        items.push({\n          src: imageLink,\n          title: imageCaption\n        });\n      });\n\n    $.magnificPopup.open({\n      items: items,\n      type: "image",\n      gallery: {\n        enabled: true\n      },\n      mainClass: "mfp-zoom-in",\n      callbacks: {\n        open: function() {\n          //overwrite default prev + next function. Add timeout for css3 crossfade animation\n          $.magnificPopup.instance.next = function() {\n            var self = this;\n            self.wrap.removeClass("mfp-image-loaded");\n            setTimeout(function() {\n              $.magnificPopup.proto.next.call(self);\n            }, 120);\n          };\n          $.magnificPopup.instance.prev = function() {\n            var self = this;\n            self.wrap.removeClass("mfp-image-loaded");\n            setTimeout(function() {\n              $.magnificPopup.proto.prev.call(self);\n            }, 120);\n          };\n        },\n        imageLoadComplete: function() {\n          var self = this;\n          setTimeout(function() {\n            self.wrap.addClass("mfp-image-loaded");\n          }, 16);\n        }\n      }\n    });\n  });\n\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  //////////////////////////////////////       full screen search        ///////////////////////////////////////////\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  $(".btn-nav-search").on("click", function(e) {\n    e.preventDefault();\n    $("#search").addClass("open");\n    $(\'#search > form > div > input[type="search"]\').focus();\n  });\n\n  $("#search, #search .search-close, #search .search-close .fa-close").on(\n    "click keyup",\n    function(e) {\n      if (\n        e.target == this ||\n        e.target.className == "search-close" ||\n        e.keyCode == 27\n      ) {\n        $(this).removeClass("open");\n        $(this)\n          .parent()\n          .removeClass("open");\n        $(this)\n          .parent()\n          .parent()\n          .removeClass("open");\n      }\n    }\n  );\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n})(jQuery);\n\n\n//# sourceURL=webpack:///./js/main.js?'
        );

        /***/
      },

    /***/ "./node_modules/smoothState/src/jquery.smoothState.js":
      /*!************************************************************!*\
  !*** ./node_modules/smoothState/src/jquery.smoothState.js ***!
  \************************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        eval(
          "/**\n * smoothState.js is a jQuery plugin to stop page load jank.\n *\n * This jQuery plugin progressively enhances page loads to\n * behave more like a single-page application.\n *\n * @author  Miguel Ángel Pérez   reachme@miguel-perez.com\n * @see     https://github.com/miguel-perez/jquery.smoothState.js\n *\n */\n\n;(function ( $, window, document, undefined ) {\n  'use strict';\n\n  /** Abort if browser does not support pushState */\n  if(!window.history.pushState) {\n    // setup a dummy fn, but don't intercept on link clicks\n    $.fn.smoothState = function() { return this; };\n    $.fn.smoothState.options = {};\n    return;\n  }\n\n  /** Abort if smoothState is already present **/\n  if($.fn.smoothState) { return; }\n\n  var\n    /** Used later to scroll page to the top */\n    $body = $('html, body'),\n\n    /** Used in debug mode to console out useful warnings */\n    consl = window.console,\n\n    /** Plugin default options, will be exposed as $fn.smoothState.options */\n    defaults = {\n\n      /** If set to true, smoothState will log useful debug information instead of aborting */\n      debug: false,\n\n      /** jQuery selector to specify which anchors smoothState should bind to */\n      anchors: 'a',\n\n      /** jQuery selector to specify which forms smoothState should bind to */\n      forms: 'form',\n\n      /** A selector that defines what should be ignored by smoothState */\n      blacklist: '.no-smoothState',\n\n      /** If set to true, smoothState will prefetch a link's contents on hover */\n      prefetch: false,\n\n      /** The number of pages smoothState will try to store in memory */\n      cacheLength: 0,\n\n      /** Class that will be applied to the body while the page is loading */\n      loadingClass: 'is-loading',\n\n      /**\n       * A function that can be used to alter the ajax request settings before it is called\n       * @param  {Object} request jQuery.ajax settings object that will be used to make the request\n       * @return {Object}         Altered request object\n       */\n      alterRequest: function (request) {\n        return request;\n      },\n\n      /** Run before a page load has been activated */\n      onBefore: function ($currentTarget, $container) {},\n\n      /** Run when a page load has been activated */\n      onStart: {\n        duration: 0,\n        render: function ($container) {}\n      },\n\n      /** Run if the page request is still pending and onStart has finished animating */\n      onProgress: {\n        duration: 0,\n        render: function ($container) {}\n      },\n\n      /** Run when requested content is ready to be injected into the page  */\n      onReady: {\n        duration: 0,\n        render: function ($container, $newContent) {\n          $container.html($newContent);\n        }\n      },\n\n      /** Run when content has been injected and all animations are complete  */\n      onAfter: function($container, $newContent) {}\n    },\n\n    /** Utility functions that are decoupled from smoothState */\n    utility = {\n\n      /**\n       * Checks to see if the url is external\n       * @param   {string}    url - url being evaluated\n       * @see     http://stackoverflow.com/questions/6238351/fastest-way-to-detect-external-urls\n       *\n       */\n      isExternal: function (url) {\n        var match = url.match(/^([^:\\/?#]+:)?(?:\\/\\/([^\\/?#]*))?([^?#]+)?(\\?[^#]*)?(#.*)?/);\n        if (typeof match[1] === 'string' && match[1].length > 0 && match[1].toLowerCase() !== window.location.protocol) {\n          return true;\n        }\n        if (typeof match[2] === 'string' &&\n          match[2].length > 0 &&\n          match[2].replace(new RegExp(':(' + {'http:': 80, 'https:': 443}[window.location.protocol] +\n            ')?$'), '') !== window.location.host) {\n          return true;\n        }\n        return false;\n      },\n\n      /**\n       * Strips the hash from a url and returns the new href\n       * @param   {string}    href - url being evaluated\n       *\n       */\n      stripHash: function(href) {\n        return href.replace(/#.*/, '');\n      },\n\n      /**\n       * Checks to see if the url is an internal hash\n       * @param   {string}    href - url being evaluated\n       * @param   {string}    prev - previous url (optional)\n       *\n       */\n      isHash: function (href, prev) {\n        prev = prev || window.location.href;\n\n        var hasHash = (href.indexOf('#') > -1) ? true : false,\n            samePath = (utility.stripHash(href) === utility.stripHash(prev)) ? true : false;\n\n        return (hasHash && samePath);\n      },\n\n      /**\n       * Translates a url string into a $.ajax settings obj\n       * @param  {Object|String} request url or settings obj\n       * @return {Object}        settings object\n       */\n      translate: function(request) {\n          var defaults = {\n            dataType: 'html',\n            type: 'GET'\n          };\n          if(typeof request === 'string') {\n            request = $.extend({}, defaults, { url: request });\n          } else {\n            request = $.extend({}, defaults, request);\n          }\n          return request;\n      },\n\n      /**\n       * Checks to see if we should be loading this URL\n       * @param   {string}    url - url being evaluated\n       * @param   {string}    blacklist - jquery selector\n       *\n       */\n      shouldLoadAnchor: function ($anchor, blacklist) {\n        var href = $anchor.prop('href');\n        // URL will only be loaded if it's not an external link, hash, or blacklisted\n        return (!utility.isExternal(href) && !utility.isHash(href) && !$anchor.is(blacklist) && !$anchor.prop('target'));\n      },\n\n      /**\n       * Resets an object if it has too many properties\n       *\n       * This is used to clear the 'cache' object that stores\n       * all of the html. This would prevent the client from\n       * running out of memory and allow the user to hit the\n       * server for a fresh copy of the content.\n       *\n       * @param   {object}    obj\n       * @param   {number}    cap\n       *\n       */\n      clearIfOverCapacity: function (cache, cap) {\n        // Polyfill Object.keys if it doesn't exist\n        if (!Object.keys) {\n          Object.keys = function (obj) {\n            var keys = [],\n              k;\n            for (k in obj) {\n              if (Object.prototype.hasOwnProperty.call(obj, k)) {\n                keys.push(k);\n              }\n            }\n            return keys;\n          };\n        }\n\n        if (Object.keys(cache).length > cap) {\n          cache = {};\n        }\n\n        return cache;\n      },\n\n      /**\n       * Stores a document fragment into an object\n       * @param   {object}    object - object where it will be sotred\n       * @param   {string}    url - name of the entry\n       * @param   {string|document}    doc - entire html\n       * @param   {string}    id - the id of the fragment\n       *\n       */\n      storePageIn: function (object, url, doc, id) {\n        var $newDoc = $(doc);\n\n        object[url] = { // Content is indexed by the url\n          status: 'loaded',\n          // Stores the title of the page, .first() prevents getting svg titles\n          title: $newDoc.filter('title').first().text(),\n          html: $newDoc.filter('#' + id), // Stores the contents of the page\n        };\n        return object;\n      },\n\n      /**\n       * Triggers an 'allanimationend' event when all animations are complete\n       * @param   {object}    $element - jQuery object that should trigger event\n       * @param   {string}    resetOn - which other events to trigger allanimationend on\n       *\n       */\n      triggerAllAnimationEndEvent: function ($element, resetOn) {\n\n        resetOn = ' ' + resetOn || false;\n\n        var animationCount = 0,\n          animationstart = 'animationstart webkitAnimationStart oanimationstart MSAnimationStart',\n          animationend = 'animationend webkitAnimationEnd oanimationend MSAnimationEnd',\n          eventname = 'allanimationend',\n          onAnimationStart = function (e) {\n            if ($(e.delegateTarget).is($element)) {\n              e.stopPropagation();\n              animationCount++;\n            }\n          },\n          onAnimationEnd = function (e) {\n            if ($(e.delegateTarget).is($element)) {\n              e.stopPropagation();\n              animationCount--;\n              if(animationCount === 0) {\n                $element.trigger(eventname);\n              }\n            }\n          };\n\n        $element.on(animationstart, onAnimationStart);\n        $element.on(animationend, onAnimationEnd);\n\n        $element.on('allanimationend' + resetOn, function(){\n          animationCount = 0;\n          utility.redraw($element);\n        });\n      },\n\n      /** Forces browser to redraw elements */\n      redraw: function ($element) {\n        $element.height();\n      }\n    },\n\n    /** Handles the popstate event, like when the user hits 'back' */\n    onPopState = function ( e ) {\n      if(e.state !== null) {\n        var url = window.location.href,\n          $page = $('#' + e.state.id),\n          page = $page.data('smoothState');\n\n        if(page.href !== url && !utility.isHash(url, page.href)) {\n          page.load(url, false);\n        }\n      }\n    },\n\n    /** Constructor function */\n    Smoothstate = function ( element, options ) {\n      var\n        /** Container element smoothState is run on */\n        $container = $(element),\n\n        /** ID of the main container */\n        elementId = $container.prop('id'),\n\n        /** If a hash was clicked, we'll store it here so we\n         *  can scroll to it once the new page has been fully\n         *  loaded.\n         */\n        targetHash = null,\n\n        /** Used to prevent fetching while we transition so\n         *  that we don't mistakenly override a cache entry\n         *  we need.\n         */\n        isTransitioning = false,\n\n        /** Variable that stores pages after they are requested */\n        cache = {},\n\n        /** Url of the content that is currently displayed */\n        currentHref = window.location.href,\n\n        /**\n         * Clears a given page from the cache, if no url is provided\n         * it will clear the entire cache.\n         * @param  {String} url entry that is to be deleted.\n         */\n        clear = function(url) {\n          url = url || false;\n          if(url && cache.hasOwnProperty(url)) {\n            delete cache[url];\n          } else {\n            cache = {};\n          }\n          $container.data('smoothState').cache = cache;\n        },\n\n        /**\n         * Fetches the contents of a url and stores it in the 'cache' variable\n         * @param  {String|Object}   request  url or request settings object\n         * @param  {Function} callback function that will run as soon as it finishes\n         */\n        fetch = function (request, callback) {\n\n          // Sets a default in case a callback is not defined\n          callback = callback || $.noop;\n\n          // Allows us to accept a url string or object as the ajax settings\n          var settings = utility.translate(request);\n\n          // Don't prefetch if we have the content already or if it's a form\n          if(cache.hasOwnProperty(settings.url) && typeof settings.data === 'undefined') {\n            return;\n          }\n\n          // Check the length of the cache and clear it if needed\n          cache = utility.clearIfOverCapacity(cache, options.cacheLength);\n\n          // Let other parts of the code know we're working on getting the content\n          cache[settings.url] = { status: 'fetching' };\n\n          // Make the ajax request\n          var ajaxRequest = $.ajax(settings);\n\n          // Store contents in cache variable if successful\n          ajaxRequest.success(function (html) {\n            utility.storePageIn(cache, settings.url, html, elementId);\n            $container.data('smoothState').cache = cache;\n          });\n\n          // Mark as error to be acted on later\n          ajaxRequest.error(function () {\n            cache[settings.url].status = 'error';\n          });\n\n          // Call fetch callback\n          if(callback) {\n            ajaxRequest.complete(callback);\n          }\n        },\n\n        repositionWindow = function(){\n          // Scroll to a hash anchor on destination page\n          if(targetHash) {\n            var $targetHashEl = $(targetHash, $container);\n            if($targetHashEl.length){\n              var newPosition = $targetHashEl.offset().top;\n              document.body.scrollTop = newPosition;\n            }\n            targetHash = null;\n          }\n        },\n\n        /** Updates the contents from cache[url] */\n        updateContent = function (url) {\n          // If the content has been requested and is done:\n          var containerId = '#' + elementId,\n              $newContent = cache[url] ? $(cache[url].html.html()) : null;\n\n          if($newContent.length) {\n\n            // Update the title\n            document.title = cache[url].title;\n\n            // Update current url\n            $container.data('smoothState').href = url;\n\n            // Remove loading class\n            if(options.loadingClass) {\n              $body.removeClass(options.loadingClass);\n            }\n\n            // Call the onReady callback and set delay\n            options.onReady.render($container, $newContent);\n\n            $container.one('ss.onReadyEnd', function(){\n\n              // Allow prefetches to be made again\n              isTransitioning = false;\n\n              // Run callback\n              options.onAfter($container, $newContent);\n\n              repositionWindow();\n\n            });\n\n            window.setTimeout(function(){\n              $container.trigger('ss.onReadyEnd');\n            }, options.onReady.duration);\n\n          } else if (!$newContent && options.debug && consl) {\n            // Throw warning to help debug in debug mode\n            consl.warn('No element with an id of ' + containerId + ' in response from ' + url + ' in ' + cache);\n          } else {\n            // No content availble to update with, aborting...\n            window.location = url;\n          }\n        },\n\n        /**\n         * Loads the contents of a url into our container\n         * @param   {string}    url\n         * @param   {bool}      push - used to determine if we should\n         *                      add a new item into the history object\n         */\n        load = function (request, push) {\n\n          var settings = utility.translate(request);\n\n          /** Makes this an optional variable by setting a default */\n          if(typeof push === 'undefined') {\n            push = true;\n          }\n\n          var\n            /** Used to check if the onProgress function has been run */\n            hasRunCallback = false,\n\n            callbBackEnded = false,\n\n            /** List of responses for the states of the page request */\n            responses = {\n\n              /** Page is ready, update the content */\n              loaded: function () {\n                var eventName = hasRunCallback ? 'ss.onProgressEnd' : 'ss.onStartEnd';\n\n                if(!callbBackEnded || !hasRunCallback) {\n                  $container.one(eventName, function(){\n                    updateContent(settings.url);\n                  });\n                } else if(callbBackEnded) {\n                  updateContent(settings.url);\n                }\n\n                if(push) {\n                  window.history.pushState({ id: elementId }, cache[settings.url].title, settings.url);\n                }\n              },\n\n              /** Loading, wait 10 ms and check again */\n              fetching: function () {\n\n                if(!hasRunCallback) {\n\n                  hasRunCallback = true;\n\n                  // Run the onProgress callback and set trigger\n                  $container.one('ss.onStartEnd', function(){\n\n                    // Add loading class\n                    if(options.loadingClass) {\n                      $body.addClass(options.loadingClass);\n                    }\n\n                    options.onProgress.render($container);\n\n                    window.setTimeout(function (){\n                      $container.trigger('ss.onProgressEnd');\n                      callbBackEnded = true;\n                    }, options.onProgress.duration);\n\n                  });\n                }\n\n                window.setTimeout(function () {\n                  // Might of been canceled, better check!\n                  if(cache.hasOwnProperty(settings.url)){\n                    responses[cache[settings.url].status]();\n                  }\n                }, 10);\n              },\n\n              /** Error, abort and redirect */\n              error: function (){\n                if(options.debug && consl) {\n                  consl.log('There was an error loading: ' + settings.url);\n                } else {\n                  window.location = settings.url;\n                }\n              }\n            };\n\n          if (!cache.hasOwnProperty(settings.url)) {\n            fetch(settings);\n          }\n\n          // Run the onStart callback and set trigger\n          options.onStart.render($container);\n\n          window.setTimeout(function(){\n            $body.scrollTop(0);\n            $container.trigger('ss.onStartEnd');\n          }, options.onStart.duration);\n\n          // Start checking for the status of content\n          responses[cache[settings.url].status]();\n        },\n\n        /**\n         * Binds to the hover event of a link, used for prefetching content\n         * @param   {object}    event\n         */\n        hoverAnchor = function (event) {\n          var request,\n              $anchor = $(event.currentTarget);\n\n          if (utility.shouldLoadAnchor($anchor, options.blacklist) && !isTransitioning) {\n            event.stopPropagation();\n            request = utility.translate($anchor.prop('href'));\n            request = options.alterRequest(request);\n            fetch(request);\n          }\n        },\n\n        /**\n         * Binds to the click event of a link, used to show the content\n         * @param   {object}    event\n         */\n        clickAnchor = function (event) {\n          var $anchor = $(event.currentTarget);\n\n          // Ctrl (or Cmd) + click must open a new tab\n          if (!event.metaKey && !event.ctrlKey && utility.shouldLoadAnchor($anchor, options.blacklist)) {\n            var request = utility.translate($anchor.prop('href'));\n\n            // stopPropagation so that event doesn't fire on parent containers.\n            isTransitioning = true;\n            event.stopPropagation();\n            event.preventDefault();\n            targetHash = $anchor.prop('hash');\n\n            // Allows modifications to the request\n            request = options.alterRequest(request);\n\n            options.onBefore($anchor, $container);\n\n            load(request);\n          }\n        },\n\n        /**\n         * Binds to form submissions\n         * @param  {Event} event\n         */\n        submitForm = function (event) {\n          var $form = $(event.currentTarget);\n\n          if(!$form.is(options.blacklist)){\n            event.preventDefault();\n            event.stopPropagation();\n\n            var request = {\n                  url: $form.prop('action'),\n                  data: $form.serialize(),\n                  type: $form.prop('method')\n                };\n\n            isTransitioning = true;\n\n            request = options.alterRequest(request);\n\n            if(request.type.toLowerCase() === 'get') {\n              request.url = request.url + '?' + request.data;\n            }\n\n            // Call the onReady callback and set delay\n            options.onBefore($form, $container);\n\n            load(request);\n          }\n        },\n\n        /**\n         * Binds all events and inits functionality\n         * @param   {object}    event\n         */\n        bindEventHandlers = function ($element) {\n\n          $element.on('click', options.anchors, clickAnchor);\n\n          $element.on('submit', options.forms, submitForm);\n\n          if (options.prefetch) {\n            $element.on('mouseover touchstart', options.anchors, hoverAnchor);\n          }\n        },\n\n        /** Restart the container's css animations */\n        restartCSSAnimations = function () {\n          var classes = $container.prop('class');\n          $container.removeClass(classes);\n          utility.redraw($container);\n          $container.addClass(classes);\n        };\n\n      /** Merge defaults and global options into current configuration */\n      options = $.extend( {}, $.fn.smoothState.options, options );\n\n      /** Sets a default state */\n      if(window.history.state === null) {\n        window.history.replaceState({ id: elementId }, document.title, currentHref);\n      }\n\n      /** Stores the current page in cache variable */\n      utility.storePageIn(cache, currentHref, document.documentElement.outerHTML, elementId);\n\n      /** Bind all of the event handlers on the container, not anchors */\n      utility.triggerAllAnimationEndEvent($container, 'ss.onStartEnd ss.onProgressEnd ss.onEndEnd');\n\n      /** Bind all of the event handlers on the container, not anchors */\n      bindEventHandlers($container);\n\n      /** Public methods */\n      return {\n        href: currentHref,\n        cache: cache,\n        clear: clear,\n        load: load,\n        fetch: fetch,\n        restartCSSAnimations: restartCSSAnimations\n      };\n    },\n\n    /** Returns elements with smoothState attached to it */\n    declaresmoothState = function ( options ) {\n      return this.each(function () {\n        var tagname = this.tagName.toLowerCase();\n        // Checks to make sure the smoothState element has an id and isn't already bound\n        if(this.id && tagname !== 'body' && tagname !== 'html' && !$.data(this, 'smoothState')) {\n          // Makes public methods available via $('element').data('smoothState');\n          $.data(this, 'smoothState', new Smoothstate(this, options));\n        } else if (!this.id && consl) {\n          // Throw warning if in debug mode\n          consl.warn('Every smoothState container needs an id but the following one does not have one:', this);\n        } else if ((tagname === 'body' || tagname === 'html') && consl) {\n          // We dont support making th html or the body element the smoothstate container\n          consl.warn('The smoothstate container cannot be the ' + this.tagName + ' tag');\n        }\n      });\n    };\n\n  /** Sets the popstate function */\n  window.onpopstate = onPopState;\n\n  /** Makes utility functions public for unit tests */\n  $.smoothStateUtility = utility;\n\n  /** Defines the smoothState plugin */\n  $.fn.smoothState = declaresmoothState;\n\n  /* expose the default options */\n  $.fn.smoothState.options = defaults;\n\n})(jQuery, window, document);\n\n\n//# sourceURL=webpack:///./node_modules/smoothState/src/jquery.smoothState.js?"
        );

        /***/
      }

    /******/
  }
);
